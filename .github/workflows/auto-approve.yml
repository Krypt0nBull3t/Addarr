# File: .github/workflows/auto-approve.yml
# Description: AI-powered PR review and auto-approve when CI passes

name: PR Review

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]

permissions:
  pull-requests: write
  contents: read

jobs:
  review:
    runs-on: ubuntu-latest
    if: >
      github.event.workflow_run.event == 'pull_request' &&
      (github.event.workflow_run.conclusion == 'success' ||
       github.event.workflow_run.conclusion == 'failure')
    steps:
      - name: Get PR number and diff
        id: pr
        uses: actions/github-script@v8
        with:
          script: |
            // Find the PR for this branch
            const pulls = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
            });
            if (pulls.data.length === 0) {
              core.setFailed('No open PR found for this branch');
              return;
            }
            const prNumber = pulls.data[0].number;
            core.setOutput('number', prNumber);

            // Get the diff
            const diff = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              mediaType: { format: 'diff' }
            });
            const fs = require('fs');
            // Truncate diff to ~100KB to stay within model context limits
            const diffText = diff.data.substring(0, 100000);
            fs.writeFileSync('pr_diff.txt', diffText);

            // Get PR details
            const pr = pulls.data[0];
            core.setOutput('title', pr.title);
            core.setOutput('body', pr.body || 'No description provided');

      - name: Filter diff for code review
        if: steps.pr.outputs.number
        run: |
          # Split diff into per-file sections and exclude non-code paths
          # Excluded: .claude/, docs/, .md files, .yml/.yaml in non-workflow dirs
          python3 << 'FILTER_EOF'
          import re

          with open('pr_diff.txt', 'r') as f:
              diff = f.read()

          # Paths to exclude from rule-based checks (not source code)
          EXCLUDE_PATTERNS = [
              r'^\.claude/',
              r'^docs/',
              r'\.md$',
          ]

          # Split into per-file hunks
          file_diffs = re.split(r'(?=^diff --git )', diff, flags=re.MULTILINE)
          code_diffs = []

          for section in file_diffs:
              if not section.strip():
                  continue
              # Extract file path from "diff --git a/path b/path" or "+++ b/path"
              match = re.search(r'\+\+\+ b/(.+)', section)
              if not match:
                  continue
              path = match.group(1).strip()
              # Skip excluded paths
              if any(re.search(p, path) for p in EXCLUDE_PATTERNS):
                  continue
              code_diffs.append(section)

          with open('pr_diff_code.txt', 'w') as f:
              f.write('\n'.join(code_diffs))
          FILTER_EOF

      - name: Rule-based checks
        id: rules
        if: steps.pr.outputs.number
        run: |
          WARNINGS=""

          # Use filtered diff (code only) for rule checks
          DIFF_FILE="pr_diff_code.txt"

          # Check for TODO/FIXME/HACK comments in added lines
          TODOS=$(grep "^+" "$DIFF_FILE" | grep -iE "(TODO|FIXME|HACK|XXX)" | head -10 || true)
          if [ -n "$TODOS" ]; then
            WARNINGS="${WARNINGS}\n**TODOs/FIXMEs found in new code:**\n\`\`\`\n${TODOS}\n\`\`\`\n"
          fi

          # Check for print statements in added Python lines
          PRINTS=$(grep "^+" "$DIFF_FILE" | grep -E "^\+.*\bprint\(" | grep -v "^+++" | grep -v "#" | head -10 || true)
          if [ -n "$PRINTS" ]; then
            WARNINGS="${WARNINGS}\n**Print statements found (use logger instead):**\n\`\`\`\n${PRINTS}\n\`\`\`\n"
          fi

          # Check for large files (>500 lines added) â€” count per file
          LARGE_FILES=$(awk '
            /^diff --git/ { if (fname && count > 500) print "- " fname " (" count " lines added)"; fname=""; count=0 }
            /^\+\+\+ b\// { fname=$0; sub(/^\+\+\+ b\//, "", fname) }
            /^\+[^+]/ { count++ }
            END { if (fname && count > 500) print "- " fname " (" count " lines added)" }
          ' pr_diff.txt || true)
          if [ -n "$LARGE_FILES" ]; then
            WARNINGS="${WARNINGS}\n**Large changes detected:**\n${LARGE_FILES}\n"
          fi

          # Check for hardcoded secrets patterns
          SECRETS=$(grep "^+" "$DIFF_FILE" | grep -iE "(api_key|apikey|secret|password|token)\s*=\s*['\"][^'\"]+['\"]" | grep -v "^+++" | head -5 || true)
          if [ -n "$SECRETS" ]; then
            WARNINGS="${WARNINGS}\n**âš ï¸ Possible hardcoded secrets found â€” please verify:**\n\`\`\`\n${SECRETS}\n\`\`\`\n"
          fi

          # Check for bare except clauses
          BARE_EXCEPT=$(grep "^+" "$DIFF_FILE" | grep -E "^\+\s*except\s*:" | grep -v "^+++" | head -5 || true)
          if [ -n "$BARE_EXCEPT" ]; then
            WARNINGS="${WARNINGS}\n**Bare except clauses found (use specific exceptions):**\n\`\`\`\n${BARE_EXCEPT}\n\`\`\`\n"
          fi

          if [ -n "$WARNINGS" ]; then
            echo "found=true" >> $GITHUB_OUTPUT
            # Write to file to preserve formatting
            printf "%b" "$WARNINGS" > rule_warnings.txt
          else
            echo "found=false" >> $GITHUB_OUTPUT
            echo "No issues found" > rule_warnings.txt
          fi

      - name: AI code review via Groq
        id: ai_review
        if: steps.pr.outputs.number
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PR_TITLE: ${{ steps.pr.outputs.title }}
          PR_BODY: ${{ steps.pr.outputs.body }}
        run: |
          # Build request with Python â€” use code-only diff, cap at 32KB for token limits
          python3 << 'PYEOF'
          import json, os

          # Prefer filtered diff (code only), fall back to full diff
          diff_file = 'pr_diff_code.txt' if os.path.exists('pr_diff_code.txt') else 'pr_diff.txt'
          with open(diff_file, 'r') as f:
              diff = f.read()

          # Cap diff size to ~80KB to stay within Groq token limits
          if len(diff) > 80000:
              diff = diff[:80000] + "\n\n... (diff truncated for token limit)"

          title = os.environ.get('PR_TITLE', 'PR Review')
          pr_body = os.environ.get('PR_BODY', '').strip()
          description = f"\n\nPR Description:\n{pr_body}" if pr_body else ""

          request = {
              "model": "llama-3.3-70b-versatile",
              "temperature": 0.3,
              "max_tokens": 4096,
              "messages": [
                  {
                      "role": "system",
                      "content": (
                          "You are a strict code reviewer for Addarr, a Python Telegram bot "
                          "using python-telegram-bot v20+, aiohttp, and a layered architecture "
                          "(handlers, services, API clients). All I/O is async.\n\n"
                          "This project values minimal, focused changes. Most PRs are correct "
                          "and clean. A good review often has zero issues and zero suggestions. "
                          "Only report problems you are confident would cause a real failure.\n\n"
                          "QUALIFICATION PROCESS â€” for each potential issue, ask yourself:\n"
                          "1. Will this cause a runtime error, wrong result, or security hole? "
                          "If no, skip it.\n"
                          "2. Is this within the scope of what the PR actually changes? "
                          "If no, skip it.\n"
                          "3. Does this involve user input or an external API boundary? "
                          "Internal code paths that read bundled project files or call internal "
                          "functions are trusted and do not need extra error handling.\n"
                          "4. Am I suggesting a library replacement or architectural change? "
                          "Skip it â€” only the PR author decides those.\n\n"
                          "QUALIFIED issues are:\n"
                          "- Bugs that produce wrong results or crash at runtime\n"
                          "- Security vulnerabilities (injection, credential exposure)\n"
                          "- Breaking changes to existing behavior\n"
                          "- Resource leaks (unclosed sessions, missing await)\n"
                          "- Incorrect assumptions about external API response shapes\n"
                          "- Logic errors where the return value contradicts the function "
                          "name, docstring, or stated intent in the PR description\n\n"
                          "Format:\n"
                          "## Summary\nOne paragraph overview.\n\n"
                          "## Issues\nOnly qualified issues, or 'No issues found.'\n\n"
                          "## Suggestions\nOnly if you identified a specific, actionable fix "
                          "for a qualified issue, or 'No suggestions.'\n\n"
                          "If the code is correct, respond with 'No issues found.' and "
                          "'No suggestions.' â€” this is the expected outcome for most PRs."
                      )
                  },
                  {
                      "role": "user",
                      "content": f"Review this PR.\n\nTitle: {title}{description}\n\nDiff:\n{diff}"
                  }
              ]
          }

          with open('request.json', 'w') as f:
              json.dump(request, f)

          print(f"Diff source: {diff_file} ({len(diff)} chars)")
          PYEOF

          # Call Groq API
          HTTP_CODE=$(curl -s -o response.json -w "%{http_code}" -X POST \
            "https://api.groq.com/openai/v1/chat/completions" \
            -H "Authorization: Bearer ${GROQ_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @request.json)

          echo "Groq API HTTP status: ${HTTP_CODE}"

          # Extract the review text and strip any reasoning blocks
          python3 << 'PYEOF' > ai_review.txt
          import json, re, sys

          with open('response.json', 'r') as f:
              data = json.load(f)

          # Check for API error response
          if 'error' in data:
              err = data['error']
              msg = err.get('message', str(err))
              print(f"AI review unavailable (API error): {msg}", file=sys.stderr)
              print(f"AI review unavailable: {msg}")
              sys.exit(0)

          try:
              content = data['choices'][0]['message']['content']
              content = re.sub(r'<think>.*?</think>\s*', '', content, flags=re.DOTALL)
              print(content.strip())
          except (KeyError, IndexError) as e:
              print(f"Unexpected API response structure: {list(data.keys())}", file=sys.stderr)
              print(f"AI review unavailable: unexpected response format")
          PYEOF

      - name: Post review comment
        if: steps.pr.outputs.number
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.REVIEWER_BOT_TOKEN }}
          script: |
            const fs = require('fs');
            const aiReview = fs.readFileSync('ai_review.txt', 'utf8');
            const ruleWarnings = fs.readFileSync('rule_warnings.txt', 'utf8');
            const hasWarnings = '${{ steps.rules.outputs.found }}' === 'true';

            let body = `## ðŸ¤– Automated PR Review\n\n`;
            body += `### AI Review\n${aiReview}\n\n`;

            if (hasWarnings) {
              body += `### âš ï¸ Rule-based Warnings\n${ruleWarnings}\n\n`;
            } else {
              body += `### âœ… Rule-based Checks\nNo issues found.\n\n`;
            }

            // Post the review comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ steps.pr.outputs.number }},
              body: body
            });

      - name: Approve PR
        if: >
          steps.pr.outputs.number &&
          github.event.workflow_run.conclusion == 'success'
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.REVIEWER_BOT_TOKEN }}
          script: |
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: ${{ steps.pr.outputs.number }},
              event: 'APPROVE',
              body: 'All CI checks passed. Review complete â€” auto-approved.'
            });
